# 正则表达式（RegularExpression,re）
- 是一个计算机科学的概念
- 用于使用单个字符串来描述，匹配复核某个规则的字符串
- 常常用来检索，替换某些模式的文本

# 正则的写法
- 正则表达式的模式：
    -   模式	        描述
    -   .	            匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
    -   [...]	        用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
    -   re*	            匹配0个或多个的表达式。
    -   re+	            匹配1个或多个的表达式。
    -   re?	            匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
    -   re{n}	        精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。
    -   re{n,}	        匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。
    -   re{n,m}         匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
    -   \w	            匹配字母数字及下划线 a-z,A-Z,0-9,_
    -   \W	            匹配非字母数字及下划线
    -   \s	            匹配任意空白字符，等价于 [\t\n\r\f].
    -   \S	            匹配任意非空字符
    -   \d	            匹配任意数字，等价于 [0-9].
    -   \D	            匹配任意非数字
    -   \A	            匹配字符串开始
    -   \Z	            匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。
    -   \z	            匹配字符串结束
    -   \G	            匹配最后匹配完成的位置。
    -   \b	            匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
    -   \B	            匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
    -   ^	            匹配字符串的开头
    -   $	            匹配字符串的末尾。-   [^...]	        不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
    -   a| b	        匹配a或b
    -   (re)	        匹配括号内的表达式，也表示一个组
    -   (?imx)	        正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
    -   (?-imx)	        正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
    -   (?: re)	        类似 (...), 但是不表示一个组
    -   (?imx: re)	    在括号中使用i, m, 或 x 可选标志
    -   (?-imx: re)	    在括号中不使用i, m, 或 x 可选标志
    -   (?#...)	        注释.
    -   (?= re)	        前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
    -   (?! re)	        前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
    -   (?> re)	        匹配的独立模式，省去回溯。
    -   \n, \t,         等.	匹配一个换行符。匹配一个制表符。等
    -   \1...\9	        匹配第n个分组的内容。
    -   \10	            匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。
- 表达式举例：
    - 验证一个数字：^\d$
    - 至少有一个数字：^\d+$
    - 只能出现5~10位的数字：^\d+{5,10}$
- python re模块中正则表达式修饰符
    -   修饰符	描述
    -   re.I	使匹配对大小写不敏感
    -   re.L	做本地化识别（locale-aware）匹配
    -   re.M	多行匹配，影响 ^ 和 $
    -   re.S	使 . 匹配包括换行在内的所有字符
    -   re.U	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
    -   re.X	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。
# re的使用
- re使用步骤
    - 使用re.compile(pattern[, flags]) 生成一个一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用
    - 通过pattern对象提供的一些列方法对文本进行匹配，获取结果Match对象
    - 最后使用Match对象提供的属性和方法获取信息
- re模块常用函数
    - re.compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。
        - 语法：re.compile(pattern[, flags])
            - pattern : 一个字符串形式的正则表达式
            - flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：
                - re.I 忽略大小写
                - re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
                - re.M 多行模式
                - re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）
                - re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
                - re.X 为了增加可读性，忽略空格和 # 后面的注释
    - group():获取一个或者多个分组匹配字符串，当要获取整个匹配字符串是直接使用group()or group(0)
    - start():获取分组匹配字符串在整个字符串的起始位置，默认参数为0
    - end():获取分组匹配的字符串在整个字符串的结束位置，默认参数为0
    - span():返回的结构技术(start(gourp),end(group))
    - search(str [,pos [, endpos]]) 在字符串中查找匹配
    - findall:查找所有
    - finditer:查找，返回一个iter结果
    - search/findall 案例 02.py
    - sub 替换
        - sub(rep1,str[,count])
        - 案例03.py
    - re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。
        - 语法：re.match(pattern, string, flags=0)
            -   参数	描述
            -   pattern	匹配的正则表达式
            -   string	要匹配的字符串。
            -   flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志



