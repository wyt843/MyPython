# 环境
- anaconda
- pycharm
- python 2.7.15
- [python开发线程:线程&守护线程&全局解释器锁](https://www.cnblogs.com/jokerbj/p/7460260.html)
- [Understanding the Python GIL](http://www.dabeaz.com/python/UnderstandingGIL.pdf)

# Threading
- Python开启线程的两种方式：
    - 通过threading.Thread.start()
        - 案例 01.py
    - 通过继承threading.Thread，然后实现run方法
        - 案例 02.py
- 同一进程的多线程 进程ID 一样
    - 案例 03.py
- 同一进程的多线程共享数据
    - 案例 04.py
- 在主进程 开启子进程
    - 案例 05.py

- 守护线程
   - 守护线程和非守护线程区别：守护线程是为非守护线程提供服务的，如果没有非守护线程运行，那么守护线程也没有运行的必要
   - 需要强调的是：运行完毕并非终止运行
     - 对主进程来说，运行完毕指的是主进程代码运行完毕
     - 对守护线程来说，运行完毕指的是守护线程所在的进程内所有非守护线程统统运行完毕，守护线程才算运行完毕
   - 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束
   - 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束
   - 案例 06.py

- 共享变量
    - 同一个进程的多个线程共享数据
    - 案例 07.py
    - 应用场景：锁，信号灯
    - 锁(Lock):
        - 资源控制
        - 使用方法：
            - 加锁
            - 使用共享数据
            - 解锁
        - 案例 08.py
    - 线程安全问题：
        - 如果一个资源（变量），它对于多线程来讲，不加锁也不会有任何问题，称之为线程安全
        - 线程不安全的数据类型：list,set,dict
        - 线程安全类型：queue
    - 生产者消费者模式
        - 一个模型：消息队列（生产入队，消费出队）
        - queue 是一个用来存储队列的
        - 案例：09.py
    - 死锁案例 10.py
    - 解决死锁案例 11.py
    - semphore
        - 允许一个资源最多有几个多线程同时使用
        - 案例 12.py
    - threading.Timer
        - Timer 是利用多线程，在指定时间后启动一个功能
        - 案例 13.py
    - 可重复锁 threading.Rlock()
        - 一个资源可以一个线程多次加锁
        - 主要解决递归调用，需要申请所的情况
        - 案例 14.py

